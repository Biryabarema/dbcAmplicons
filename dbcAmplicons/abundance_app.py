# abundance_app.py
#
import sys
import os
import traceback
import re
import glob
import time
from collections import OrderedDict
from dbcAmplicons import sampleTable
from collections import Counter


class fixrankLine:
    """
    Parse a single line from fixrank formated file, generated by dbcAmplicons classify
    HWI-M01380:50:000000000-A641U:1:2116:11332:23553|Foxtrot267:16S         Bacteria        domain  1.0     "Fusobacteria"  phylum  1.0     "Fusobacteria"  class   1.0     "Fusobacteriales"     order   1.0     "Fusobacteriaceae"      family  1.0     Clostridium XIX genus   0.59
    """
    def __init__(self, line, rank='genus', threshold=0.5, biom=False):
        """
        Initialize the fixrankLine object given a 'line'
        """
        # Assume good read
        self.goodRead = True
        self.barcode = None
        self.sample = None
        self.primer = None
        self.project = None
        self.size = None
        self.taxon = OrderedDict()
        parse = line.split('\t')

        # Question, how to describe unknown in Biom file?
        # Kingdon, Phylum, Class, Order, Family, Genes, Species
        fixrank_levels = ['k__', 'p__', 'c__', 'o__', 'f__', 'g__', 's__']

        if len(parse) % 3 != 2:
            sys.stderr.write("ERROR:[fixrankline] incorrect number of columns in parsing the line, %s\n" % line)
            raise
        name = parse[0].split('|')
        name = name[1].split(':')
        self.barcode = self.sample = name[0]
        if (len(name) == 3):
            self.primer = name[1]
            self.size = name[2]
        else:
            self.size = name[1]
        # parse the taxon line
        levels = len(parse)/3
        if biom:
            self.call = ('k__unknown', 1.0, self.size)
        else:
            self.call = ('Unknown|Root', 1.0, self.size)
        for i in xrange(levels):
            # self.taxon[parse[i*3+3]] = (re.sub(r'["\']+', "",parse[i*3+2]),float(parse[i*3+4]))
            if float(parse[i*3+4]) >= threshold:
                if biom:
                    if i == 0:
                        self.call = (fixrank_levels[i] + re.sub(r'["\']+', "", parse[i*3+2]), float(parse[i*3+4]), self.size)
                    else:
                        self.call = (self.call[0] + ';' + fixrank_levels[i] + re.sub(r'["\']+', "", parse[i*3+2]), float(parse[i*3+4]), self.size)
                else:
                    self.call = (re.sub(r'["\']+', "", parse[i*3+2]) + '|' + parse[i*3+3], float(parse[i*3+4]), self.size)
                if parse[i*3+3] == rank:
                    break
            else:
                break

    def getCall(self):
        """
        Retrieve the call
        """
        return self.call

    def isOk(self):
        """
        Return whether the read is 'good' True or 'bad' False
        """
        return self.goodRead

    def getSampleID(self):
        """
        Return the reads sample ID
        """
        return self.sample

    def getProject(self):
        """
        Return the reads project ID
        """
        return self.project

    def getPrimer(self):
        """
        Return the reads project ID
        """
        return self.primer

    def assignRead(self, sTable):
        """
        Given a samplesTable object, assign a sample ID and project ID using the reads barcode and primer designation
        """
        self.sample = sTable.getSampleID(self.barcode, self.primer)
        self.project = sTable.getProjectID(self.barcode, self.primer)
        self.goodRead = self.project is not None
        return 0


class abundanceApp:
    """
    Generate an abundance table from a fixrank formated file
    Takes fixrank formatted files from dbcAmplicons classify and a taxonomic rank to build table from, allowable values are (domain, phylum, class, order, family, genus, and species{if performed}
    and output an abundance and proportions table with taxon in rows and samples as columns.
    """
    def __init__(self):
        self.verbose = False

    def start(self, fixrank_file, samplesFile, output_prefix='table', rank='genus', threshold=0.5, minsize=None, maxsize=None, biom=False, verbose=True, debug=False):
        """
            Start processing classification fixrank files
        """
        self.verbose = verbose
        evalSample = samplesFile is not None
        if biom:
            try:
                import biom
            except ImportError:
                sys.stderr.write("Cannot import python biom module")
                raise
        try:
            lines = 0
            lasttime = time.time()
            self.ffixrank = []
            # samples
            if evalSample:
                sTable = sampleTable(samplesFile)
                if verbose:
                    sys.stdout.write("sample table length: %s, and %s projects.\n" % (sTable.getSampleNumber(), len(sTable.getProjectList())))

            # check input fixrank files
            for ffile in fixrank_file:
                self.ffixrank.extend(glob.glob(ffile))
                if len(self.ffixrank) == 0 or not all(os.path.isfile(f) for f in self.ffixrank):
                    sys.stderr.write('ERROR:[abundance_app] fixrank file(s) not found\n')
                    raise

            abundanceTable = dict()
            bootscore = dict()
            tax_len = dict()
            primers = dict()
            sampleList = []
            sampleCounts = Counter()
            discardedReads = 0
            for ffile in self.ffixrank:
                with open(ffile, "rb") as infile:
                    for line in infile:
                        lrank = fixrankLine(line.rstrip('\n'), rank, threshold, biom)
                        tax = lrank.getCall()
                        if (minsize is not None or maxsize is not None) and tax[2] != "PAIR":
                            if minsize is not None and int(tax[2]) < minsize:
                                discardedReads += 1
                                continue
                            if maxsize is not None and int(tax[2]) > maxsize:
                                discardedReads += 1
                                continue
                        if evalSample:
                            lrank.assignRead(sTable)
                        if lrank.isOk():
                            if lrank.getSampleID() not in sampleList:
                                sampleList.append(lrank.getSampleID())
                                primers[lrank.getSampleID()] = []
                            sampleCounts[lrank.getSampleID()] += 1
                            if lrank.getPrimer() not in primers[lrank.getSampleID()]:
                                primers[lrank.getSampleID()].append(lrank.getPrimer())
                            if tax[0] in abundanceTable.keys():
                                abundanceTable[tax[0]][lrank.getSampleID()] += 1
                                bootscore[tax[0]] += tax[1]
                                if tax[2] == "PAIR":
                                    tax_len[tax[0]]["PAIR"] += 1
                                else:
                                    tax_len[tax[0]]["SINGLE"] += int(tax[2])
                            else:
                                abundanceTable[tax[0]] = Counter()
                                abundanceTable[tax[0]][lrank.getSampleID()] += 1
                                bootscore[tax[0]] = tax[1]
                                tax_len[tax[0]] = {}
                                if tax[2] == "PAIR":
                                    tax_len[tax[0]]["PAIR"] = 1
                                    tax_len[tax[0]]["SINGLE"] = 0
                                else:
                                    tax_len[tax[0]]["PAIR"] = 0
                                    tax_len[tax[0]]["SINGLE"] = int(tax[2])
                        lines += 1
                        if lines % 100000 is 0:
                            sys.stderr.write("processed %s total lines, %s lines/second\n" % (lines, round(lines/(time.time() - lasttime), 0)))
            if self.verbose:
                sys.stdout.write("%s lines processed in %s minutes\n" % (lines, round((time.time()-lasttime)/(60), 2)))
                if discardedReads > -1:
                    sys.stderr.write("discarded %s reads for size\n" % str(discardedReads))
                sys.stderr.write("Writing output\n")
            # output files
            # biom format
            if biom:
                # generate table formats
                data = []
                obs_ids = []
                sampleList = sorted(sampleList)
                # sampleList_md = [{'id': v} for v in sampleList]
                sampleList_md = [{'primers': ";".join(primers[v])} for v in sampleList]
                for i, v in enumerate(sampleList):
                    sampleList_md[i].update(sTable.sampleMetadata[v]["Metadata"])

                # taxanomic keys and metadata
                taxa_keys = sorted(abundanceTable.keys())
                mbootscore = {v: round(bootscore[v]/sum(abundanceTable[v].values()), 3) for v in taxa_keys}

                def calc_single_len(single, pairs, total):
                    try:
                        return single/(total-pairs)
                    except ZeroDivisionError:
                        return 0

                mtax_len_s = {v: calc_single_len(tax_len[v]["SINGLE"], tax_len[v]["PAIR"], sum(abundanceTable[v].values())) for v in taxa_keys}
                mtax_len_p = {v: round(tax_len[v]["PAIR"]/(sum(abundanceTable[v].values())), 3) for v in taxa_keys}

                def func(x): return x.split(';')
                taxa_keys_md = [{'taxonomy': func(v), 'mean_rdp_bootstrap_value': mbootscore[v], 'mean_sequence_length_single': mtax_len_s[v], 'percentage_paired': mtax_len_p[v]} for v in taxa_keys]
                # taxa_keys_md = [{'taxonomy': func(v)} for v in taxa_keys]

                # build the data object
                for i, taxa in enumerate(taxa_keys):
                    obs_ids.append("Taxa_%05d" % (i))
                    tmpd = []
                    for sample in sampleList:
                        tmpd.append(float(abundanceTable[taxa][sample]))
                    data.append(tmpd)

                # build the biom Table object
                biomT = biom.Table(data=data, observation_ids=obs_ids, sample_ids=sampleList,
                    observation_metadata=taxa_keys_md, sample_metadata=sampleList_md,
                    input_is_dense=True,
                    table_id=None, type="OTU table", create_date=None, generated_by="dbcAmplicons",
                    observation_group_metadata=None, sample_group_metadata=None)
                try:
                    import h5py1  # Temporarily deactive h5py output
                    sys.stderr.write("Writing hd5 formatted biom file to: %s\n" % (output_prefix + '.biom'))
                    with h5py.File(output_prefix + '.biom', 'w') as f:
                        biomT.to_hdf5(f, "dbcAmplicons")
                except ImportError:
                    sys.stderr.write("Writing json formatted biom file to: %s\n" % (output_prefix + '.biom'))
                    with open(output_prefix + '.biom', 'w') as f:
                        f.write(biomT.to_json("dbcAmplicons"))
                # if evalSample:
                #     ab_name = output_prefix + '.biom'
                # else:
                #     ab_name = output_prefix + '.biom'
                # try:
                #     abFile = open(ab_name, 'w')
                # except:
                #     sys.stderr.write("ERROR:[abundance_app] Can't open files (%s) for writing\n" % (ab_name))
                # # write out header line
                # sampleList = sorted(sampleList)
                # txt = 'ID\t' + '\t'.join(sampleList) + '\t' + 'taxonomy\n'
                # abFile.write(txt)
                # taxa_keys = sorted(abundanceTable.keys())
                # for i, taxa in enumerate(taxa_keys):
                #     txt1 = 'OTU_' + str(i)
                #     for sample in sampleList:
                #         txt1 = '\t'.join([txt1, str(abundanceTable[taxa][sample])])
                #     txt1 = txt1 + '\t' + taxa
                #     abFile.write(txt1 + '\n')
            # abundance and proportions
            else:
                if evalSample:
                    ab_name = output_prefix + '.abundance.txt'
                    prop_name = output_prefix + '.proportions.txt'
                else:
                    ab_name = output_prefix + '.abundance.txt'
                    prop_name = output_prefix + '.proportions.txt'
                try:
                    abFile = open(ab_name, 'w')
                    propFile = open(prop_name, 'w')
                except:
                    sys.stderr.write("ERROR:[abundance_app] Can't open files (%s,%s) for writing\n" % (ab_name, prop_name))
                # write out header line
                sampleList = sorted(sampleList)
                txt = 'Taxon_Name\tLevel\tMeanBootstraptValue\t' + '\t'.join(sampleList) + '\n'
                abFile.write(txt)
                propFile.write(txt)
                taxa_keys = sorted(abundanceTable.keys())
                for taxa in taxa_keys:
                    txt1 = txt2 = str(taxa.replace('|', '\t')) + '\t' + str(round(bootscore[taxa]/sum(abundanceTable[taxa].values()), 3))
                    for sample in sampleList:
                        txt1 = '\t'.join([txt1, str(abundanceTable[taxa][sample])])
                        if sampleCounts[sample] > 0:
                            txt2 = '\t'.join([txt2, str(float(abundanceTable[taxa][sample])/float(sampleCounts[sample]))])
                        else:
                            txt2 = '\t'.join([txt2, str(0.0)])
                    abFile.write(txt1 + '\n')
                    propFile.write(txt2 + '\n')
                txt = "Sample Counts\tNA\tNA"
                for sample in sampleList:
                        txt = '\t'.join([txt, str(sampleCounts[sample])])
                propFile.write(txt + '\n')
            # output total counts (across all samples) for each taxa
            cntFile = open(output_prefix + '.taxa_counts.txt', 'w')
            cntFile.write("Taxon_Name\tCount\n")
            for abt in abundanceTable:
                cntFile.write(str(abt) + '\t' + str(sum(abundanceTable[abt].values())) + '\n')
            if self.verbose:
                sys.stderr.write("finished in %s minutes\n" % (round((time.time()-lasttime)/(60), 2)))
            self.clean()
            return 0
        except (KeyboardInterrupt, SystemExit):
            self.clean()
            sys.stderr.write("%s unexpectedly terminated\n" % (__name__))
            return 1
        except:
            self.clean()
            sys.stderr.write("A fatal error was encountered.\n")
            if debug:
                sys.stderr.write("".join(traceback.format_exception(*sys.exc_info())))
            return 1

    def clean(self):
        if self.verbose:
            sys.stderr.write("Cleaning up.\n")
        try:
            # nothing to be done
            pass
        except:
            pass
